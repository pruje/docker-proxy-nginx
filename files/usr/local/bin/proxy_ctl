#!/bin/bash
#
#  Proxy controller
#

#
#  Functions
#

# Print command result
result() {
	local res=$?
	[ -n "$1" ] && res=$1

	if [ $res = 0 ] ; then
		echo "... ok"
	else
		echo "... FAILED (exit code: $res)"
	fi

	return $res
}


# Get a config value from a nginx config file
# Usage: get_config FILE PARAMETER
get_config() {
	grep -E "^\s*$2\s+" "$1" | tail -n 1 | sed "s/^.*$2\s//; s/;$//"
}


# Test nginx config
nginx_test() {
	local output res

	echo "Test config..."

	output=$(nginx -t 2>&1)
	res=$?

	if [ $res != 0 ] ; then
		echo "$output" | grep -q ' in /etc/nginx/conf.d/' && res=2
	fi

	# print disabled configs
	for f in /etc/nginx/conf.d/*.disabled ; do
		[ -f "$f" ] && echo "[INFO] disabled config file: $f"
	done

	# print errors
	[ $res != 0 ] && echo "$output"

	result $res
}


# Reload nginx config
nginx_reload() {
	echo "Reload nginx..."
	nginx -s reload
	result
}


#
#  Commands
#

# Initialize nginx
# Not to be documented, this command is only used by the entrypoint
cmd_init() {
	local output dest

	# try to reactivate config files
	for f in /etc/nginx/conf.d/*.disabled ; do
		[ -f "$f" ] || continue

		dest=${f:0:-9}
		if [ -f "$dest" ] ; then
			echo "[WARNING] cannot activate $f config: $dest exists!"
		else
			mv "$f" "$dest"
		fi
	done

	while true ; do
		output=$(nginx_test)
		case $? in
			0)
				break
				;;
			2)
				# for each file in error,
				for f in $(echo "$output" | grep ' in /etc/nginx/conf.d/' | grep -o '/etc/nginx/conf.d/.*' | sed 's/.conf:.*/.conf/g' | sort -u) ; do
					# rename config file
					echo "[WARNING] config file disabled due to errors: $f"
					mv "$f" "$f".disabled
				done
				;;
			*)
				# fatal error
				echo "$output"
				return 1
				;;
		esac
	done

	return 0
}


# Test proxy config
cmd_test() {
	nginx_test
}


# Reload proxy config
cmd_reload() {
	case $1 in
		-f|--force)
			cmd_init || return
			;;
	esac

	nginx_test && nginx_reload
}


# Put a config file in maintenance mode
# Usage: maintenance FILE
cmd_maintenance() {

	# usage error
	if [ -z "$1" ] ; then
		echo "Usage: proxy_ctl maintenance FILE"
		return 1
	fi

	cd /etc/nginx/conf.d || return 1

	local conf=$(basename "$1")
	if ! [ -f "$conf" ] ; then
		echo "File not found: $conf"
		return 1
	fi

	local renamed=.$conf.maintenance
	if [ -f "$renamed" ] ; then
		echo "already in maintenance"
		return 0
	fi

	if ! mv "$conf" "$renamed" ; then
		error "Failed to disable config file: $conf"
		return 1
	fi

	local server_name=$(get_config "$renamed" server_name)
	local ssl_certificate=$(get_config "$renamed" ssl_certificate)
	local ssl_certificate_key=$(get_config "$renamed" ssl_certificate_key)

	# no ssl config
	if [ -z "$server_name" ] || [ -z "$ssl_certificate" ] || [ -z "$ssl_certificate_key" ] ; then
		# create empty file to keep it in sight
		touch "$conf"
		cmd_reload
		return 0
	fi

	cp /etc/nginx/maintenance.conf "$conf" && \
	sed -i "s/server_name .*/server_name $server_name;/g; s|ssl_certificate .*|ssl_certificate $ssl_certificate;|; s|ssl_certificate_key .*|ssl_certificate_key $ssl_certificate_key;|" "$conf" && \
	cmd_reload
}


# Get a config file out of maintenance mode
# Usage: online FILE
cmd_online() {

	# usage error
	if [ -z "$1" ] ; then
		echo "Usage: proxy_ctl online FILE"
		return 1
	fi

	cd /etc/nginx/conf.d || return 1

	local conf=$(basename "$1")
	if ! [ -f "$conf" ] ; then
		echo "File not found: $conf"
		return 1
	fi

	local renamed=.$conf.maintenance
	if ! [ -f "$renamed" ] ; then
		echo "already online"
		return 0
	fi

	# restore config
	if ! mv "$renamed" "$conf" ; then
		error "Failed to enable config file: $conf"
		return 1
	fi

	cmd_reload
}


#
#  Main program
#

cmd=$1
shift

# check command
case $cmd in
	init|test|reload|maintenance|online)
		# run command
		cmd_$cmd "$@"
		;;
	certbot)
		certbot "$@" --nginx
		;;
	*)
		echo "Unknown command: $cmd"
		echo "Use proxy_ctl help to see available commands"
		exit 1
		;;
esac
